# -*- coding: utf-8 -*-
"""sesi04_bisection.ipynb - 2702221936 - Jeffrey Ferdinand Hartono

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y4A9u9ehQQtpkdpQBhi_DJvEXhBMC1he
"""

import numpy as np

def my_bisection(f, a, b, tol):
  # approximates a root, R, of f bounded
  # by a and b to within tolerance
  # | f(m) | < tol with m the midpoint
  # between a and b Recursive implementation

  # check if a and b bound a root
  if np.sign(f(a)) == np.sign(f(b)):
    raise Exception(
        "The scalars a and b do not bound a root"
    )

  # get midpoint
  m = (a + b)/2

  if np.abs(f(m)) < tol:
    # stopping condition, report m as root
    return m
  elif np.sign(f(a)) == np.sign(f(m)):
    # case where m is an improvement on a
    # Make recursive call with a = m
    return my_bisection(f, m, b, tol)
  elif np.sign(f(b)) == np.sign(f(m)):
    # case where m is an improvement on b
    # Make recursive call with b = m
    return my_bisection(f, a, m, tol)

f = lambda x: x**2 - 2

r1 = my_bisection(f, 0, 2, 0.1)
print("r1 =", r1)
r01 = my_bisection(f, 0, 2, 0.01)
print("r01 =", r01)

print("f(r1) =", f(r1))
print("f(r01) =", f(r01))

my_bisection(f, 2, 4, 0.01)
# memang error karena nilai xnya tidak di antara 2 dan 4

"""Quiz 1 Bisection

f(x) = x^3 - 3x^2 + 2x
[a,b] = [1,2]
tol = 0.01
"""

f = lambda x: x**3 - 3 * x**2 + 2 * x
a = 1
b = 2
tol = 0.01

print(my_bisection(f, a, b, tol))

"""Quiz 2 Bisection

f(x) = sin(x) - x
[a,b] = [0,1]
tol = 0.001
"""

f = lambda x: np.sin(x) - x
a = 0
b = 1
tol = 0.001

print(my_bisection(f, a, b, tol))